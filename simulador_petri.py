# -*- coding: utf-8 -*-
"""simulador_petri.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HczHdxIMlAj9hXqgrXD-qgV57wd5TmZl
"""

!pip install anytree
from anytree import Node, RenderTree

class no():
  def __init__(self):
    self.valor = None
    self.pai = []
    self.filho = []
    self.trans = None

main()

def inserir_no(u, index, p, t):
  u.append(no())
  u[index].pai = p
  u[index].trans = t

def matriz_incidencia(Pre, Pos):
  A = []
  for i in range(len(Pre)):
    A.append([])
    for j in range(len(Pre[0])):
      A[i].append(Pos[i][j] - Pre[i][j])
      
    print(A[i])

def linguagem(L):
  aux_ling = ''
  for i in range(len(L)):
    aux_ling += L[i]
  print(aux_ling)

def main():
  #informações inicias da rede
  #EXEMPLO 1
  
  P = ["p1","p2","p3"]  #Lugares
  T = ["t1","t2","t3"]  #Transições
  Pre = [[1, 0, 0],[0, 1, 0],[0, 0, 1]]
  Pos = [[0, 0, 1],[1, 0, 0],[0, 1, 0]]
  M0 = [1,0,0]          #marcação inicial
  

  #EXEMPLO 2
  """
  P = ["p1","p2"]
  T = ["t1"]
  Pre = [[1], [0]]
  Pos = [[0], [2]]
  M0 = [1,0]
  """

  #EXEMPLO 3
  """
  P = ["p1","p2","p3","p4","p5","p6"]
  T = ["t1","t2"]
  Pre = [[1, 0],[1, 0],[0, 1],[0, 0],[0, 0],[0, 0]]
  Pos = [[0, 0],[0, 0],[1, 0],[0, 1],[0, 2],[0, 3]]
  M0 = [1, 1, 0, 0, 0, 0]
  """

  #EXEMPLO 4
  """
  P = ["p1","p2","p3"]
  T = ["t1","t2","t3"]
  Pre = [[1, 1, 0],[0, 0, 1],[0, 0, 1]]
  Pos = [[1, 0, 0],[1, 1, 0],[0, 1, 1]]
  M0 = [1, 0, 0]
  """

  print("\nMatriz de Incidência")
  print("A = ")
  matriz_incidencia(Pre, Pos)

  L = [] #Linguagem da rede
  u = [] #Lista com as marcações
  k = 0
  aux = M0.copy()

  disparavel = True

  raiz = no()
  root = Node(M0)
  u.append(raiz)
  raiz.valor = M0

  #fixa j que equivale a transição
  for j in range(len(T)):
    disparavel = True

    #percorre i que equivale aos lugares
    for i in range(len(P)):
      if u[k].valor[i] < Pre[i][j]:
        disparavel = False
        break
    if disparavel == True:
      L.append(T[j])
      k = k + 1

      #inserir_no(u, k, raiz, T[i])

      u.append(no())
      u[k].pai = u[k-1]
      u[k].trans = T[j]
      u[k].pai.filho = u[k]

      #pegar o novo valor de M
      for i in range(len(P)):
        aux[i] = u[k-1].valor[i] - Pre[i][j] + Pos[i][j]
      u[k].valor = aux.copy()

  print("\nLinguagem da rede")
  linguagem(L)

  print("\nArvore de Alcançabilidade")
  if len(u) >= 2:
    level_1_child_1 = Node(u[1].valor, parent=root)
  if len(u) >= 3:
    level_2_child_1 = Node(u[2].valor, parent=level_1_child_1)
  if len(u) >= 4:
    level_3_child_1 = Node(u[3].valor, parent=level_2_child_1)
  if len(u) >= 5:
    level_4_child_1 = Node(u[4].valor, parent=level_3_child_1)

  i = 0
  for pre, fill, node in RenderTree(root):
    print("%s%s" % (pre, node.name))
    if i < len(u)-1:
      print(T[i])
      i += 1